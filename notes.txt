STANFORD CS107
https://see.stanford.edu/Course/CS107

0. First Day of Class :D
- CS106b/x prereq, looks like lots of compsci problem types/abstractions
- requires lots of C++, first few wks have work cut out for you
- MUST know:
	- arrays
	*- pointers
	- references
	- classes
	*- dynamic memory allocation
	- recursion
	- linked lists
	- binary search trees
	- hashing
	- iterators
	*- function pointers
	- decomposition
- Syllabus (points above) and Resources list on the class page
	- C++, Purify, vi/xemacs, gdb, Scheme

LECTURE 1 6/29/2017
- C
	- imperative paradigm, verb/function-oriented
	- C++ myobject -> dothis (data being manipulated)
	- that's why C++ is object- not function-oriented
	- many people think in C even while C++, sticking w functional not obj
- Assembly
	- show you how a line like j++ translates
	- C++ doesn't execute as C++
	- show how everything compiles to 0s and 1s
	- see how C++ and C almost look the same when compiling
	- gives you idea as to why crashing
- Concurrent
	- we do it in C at the moment
	- all programs prior to 107 have been sequential
	- pipelined/parallel instructions instead of clean streams
	- within a single program, get 2 funcs to (seemingly) run simultaneously
	- tends to switch back and forth so fast can't really see the diff
	- networking in particular, it's very useful
	- however, problems come up (e.g. transactional, shared resources)
	- banks and airlines worried about giving away resources
- Scheme
	- related to Lisp
	- functional paradigm representative
	- 2 things interesting vs C/C++
		- always rely on return value of func to move forward
		- program without side effects
	- such a small language and fun
- Python
	- instead of advanced C++ or Java (108 is all about Java)
	- as "a more modern, object-oriented version of PERL"
	- web programming boring, lots of HMTL, but Python has libraries
	- "great libraries", object-oriented, functional ideas even allowed
	- good vehicle for parsing and protocols
- Next time, low-level pointer stuff!

From the transcript but not in the vid:
- C more difficult but used by longtimers
- by the end you'll be able to read this: **&**P -> ***=7


LECTURE 2
- Low-level mem mechanics, how everything represented 0 1
- C/C++
	- bool, char, short, int, long, float, double
	- short, int, long all rep scalars
	- float and double for arbitrarily precise numbers
 	char 		1 byte
	short 		2 bytes
	int 		4 bytes
	long 		4 bytes
	float 		4 bytes (finite mem tries to do inf precis)
	double 		8 bytes
- binary digit => bit
	- EE think of transistors, hi/lo voltages)
	- CS just think in terms of 2 vals
	- more interesting taken in groups
	- each bit adopts value independently of others
	- therefore 8 bits can distinguish 2**8 values
- chars 
	- epresented in mem backed by some num e.g. A is 65
	- 'A' = 65 but actually some sum of powers of 2 (64+1)
	- 8 is 2**3, etc.
	- looking at all transistors would look like 01000001
	- think of powers of 2 at that position, e.g. 1 at 2**6
- shorts
	- 2 sets of 8 bits separated in 2 boxes
	- contribution of 2 to the whatever again
	- now go up you can get 2 to the 9th, etc. (2 bytes)
	- 0 followed by all 1s is 1 less than 2 to that power
	- 0 to 2**16-1 is range, BUT -2**15 to 2**15-1 instead 
	- the leftmost bit is SIGN not the MAGNITUDE
	- hogs a bit more memory if the second byte is all 0s
	- SIGN BIT: addition/sub use 2'S COMPLEMENT not 1'S C!
		- invert all bits, then add 1 in the 2**0 col!
	- want just as many negs as pos, so leftmost is neg/pos

char ch = 'A';
short s = ch; 	// don't need a cast for that, it's the num
cout << s << endl;
// prints 65 because ch just puts 65 in its bites
// then s has extra byte 0s and a "smear" of 65 in 1st byte

- shorts assigned to a char will punt on the extra byte!

- same thing it init a short as an int
	- just BIT PATTERN copy; remember this is electronics
	- no patience for dealing with the other 2 bytes

short s = -1;
	- tricky representation: 2 bytes all 1s!!
	- this is so you can add to get pos 1
int i = s;
	- NOT simple BIT PATTERN copy like the above cases
	- now the domino effect goes on into the other 2 bytes
	- the other 2 bytes are now full of 1s

- floats
	- 32 bits with a leftmost sign bit
	- think it's 2 to the 30 all the way down to 2 ** 0?
	- NOPE! could use contributions of 2 to negative num?
	- NOPE! instead don't cut it into bytes equally
		- have 1 of 32 bits as sign
		- next 8 bits are unsigned EXPONENT only
		- remaining 23 bits are 2**-1, 2**-2, 2**-3
	- in other words, it's
		(-1)**SIGN (1.xxxxxx * 2 ** exp-127)
	- tries to get dec as close to .999....
	- this is how floats rep in memory

// what happens when assign int to float or float to int
//	- has to evaluate what number the original bit pattern
//	- THEN has to lay out NEW bit pattern in float!
int i = 5;
float f = i;
// lots of 0s followed by 0101 at the end, you know
cout << f << endl;
// you'll get the number 5
// 5.0 totally different bit pattern tho
5 => 5.0 => 1.25*2**2

// can also just evaluate the location of i
int i = 37;
float f = *(float*)&i;
// &i  		we point to the address of i (type int*)
// (float*) we coax into thinking of the SAME bits as float
// * 		we dereference it, getting the value pointed at
// IF PRINTED will just get a really small number
// (because the float is a bunch of right 1s)

float f = 7.0;
short s = *(short*)&f; 	// loc in mem from leftmost spot
// looks similar prob except figures different sizes
// ALWAYS cuts from leftmost point because that's pointer!
// lay them out, you'll see right 2 bytes ignored
// assumes is short, just replicates left bit pattern
// so you just get smear of the left 2 bytes!


LECTURE 3

// clarifying confusion (we understood, some students did not)
double d = 3.1416;
char ch = *(char*)&d;
// the actual bit pattern is irrelevant
// this is an expression on the address of d
// seduced into thinking it's storing the ref of a single char
// pretending to be char for lifetime of char ch statement

short s = 45;
double d = *(double*)&s;
// most still applies, but mysterious:
// &s address assoc c that arrow
// now that thinks pointed to 8-byte double, so
// also assigns the bytes that follow
// byte pattern is 45 + more bytes

- big endian, little endian
	- 2-byte short c a 1 preceded by 0s is true for .5 systems out there
	- in other .5 are little endian, bigger magnitude bytes follow to R!
	- bit copy btwn big e machines to little e machines get difft shorts

// 4 bytes stacked on top of 4 more bytes
// address of entire struct ALWAYS coincident c first field address
// pi. denom on top, pi.num below (pi.num is where arrow points)
// don't know if it's num OR the entire struct that's being pointed
struct fraction {
	int num;
	int denom;
}
fraction pi;
pi.num = 22; 	// places 22 at 0 offset from base of entire struct
pi.denom = 7; 	// places 7 at 4 bytes above base of struct
// knows that denom is 4 bytes above the address of the num

/*
 * NOW INVADE pi.denom's space using QUIRKY SYNTAX
 * 	- change it's value using references
 */
&(pi.denom) 			// gets an int*
(fraction*)&(pi.denom)	// gets address of pi.denom as if it's fraction*
// arrow travels to struct and identifies num as place that should receive 12
((fraction*)&(pi.denom))->num = 12;
// travel to fraction struct and identify num field to receive the 12
// this replaces pi.denom from 7 to 12 "behind pi.denom's back"!

// now we smear the bytes above pi.denom with 33
// even though no way of legally accessing this because stored above struct
((fraction*)&(pi.denom))->denom = 33;

// note that to access this now you'd workaroudn to get back to those bytes
((fraction*)&(pi.denom))[0].denom;

- array is COMPLETELY synonymous with ADDRESS of the ZEROTH ENTRY
int array[10];
array[0] = 44;
array[9] = 100;
array[5] = 45;
array[11] = 1; 		// might succeed or crash based on touching local vars
					// NOT because of bounce checking
// THEOREM: array <-> &array[0]
// NO bounce checking on raw arrays, so array[11]=1 tries to place 1!!
// same with array[-4]=77

// THEOREM: array+k <-> &array[k]
// you're doing pointer arithmetic, the boundaries between ints
// k automatically scaled based on the type system (e.g. int 4 bytes wide)

// THEOREM: *array <-> array[0]
// THEOREM: *(array+k) <-> array[k]
*(array-4) = 77; 	// brings you 16 bytes before

int arr[5];
arr[3]=128; 		// bits fit and updated in right half of box 3
(short*)arr; 		// now thinks arr stores shorts
(short*) arr[6]=2; 	// writes a 2 in the left half of index 3's bytes!!
cout << arr[3] << endl; 	// prints out both left and right bits!

((short*)(((char*)(&arr[1])+8))[3]=100; 	// writes 100 way after array

- in C we don't write generics, we leverage the fact we know
	- size of everything
	- and bit pattern of everything

// 16 byte struct
struct student{
	// no string class in C++, so char arrays ending with null char
	char* name; 	// store address of zeroth char
	char suid[8]; 	// 2x 4 array blocks above name
	int numUnits; 	// int bytes above suid blocks
}
// now lay out 4 student structs side by side (like array)
student pupils[4];
pupils[0].numUnits=21; 	// 21 goes in topmost field of zeroth struct
// dynamically alloc enough space for "Adam" then returns addr of "A"
// makes enough space for \0 (end character)
pupils[2].name = strdup("Adam");

// NOW do some funkiness using those structs
pupils[3].name = pupils[0].suid+6; 	// do pointer arithmetic agst a char*
// strcpy just sees 
strcpy(pupils[1].suid, "40415xx"); 		// copy characters to suid
	// make SURE that it's char address under your jurisdiction - was fine
strcpy(pupils[3].name, "123456"); 		// copy characters to field
	// was NOT fine - [3]'s.name pointer changed above, so now
	// we're writing into pupils[0].suid+6 !!!!!
	// better make sure you own that mem if you're writing char or whatever
pupils[7].suid[11]='A'; 			// still does manual arithm to find!

- free up memory using FREE (like DELETE in other lang)
- if print out chars in char array from an index, prints all chars to right
	- final /0 doesn't print out 'naccount of being weird rep of empty string

// bit pattern swapping
void swap(int *ap, int *bp)
{
	// I know that ap and bp are just pointers to x box and y box
	int temp = *ap;
	// temp is now smeared with whatever the value of ap is
	*ap = *bp; 	// space addressed by ap is now set to what bp evaluates to
	*bp = temp; // achieve the swap
}
int x=7;
int y=117;
// C has no templates and no references, just addresses
// knows where to go to move byte patterns around
swap(&x,&y);

- in other langs we'd templatize (generic)
 	- see we can do swaps, etc. using info learned last 2 lectures
 	- it's not hacky, it's beautiful


LECTURE 4
// more notes on swap to clarify
- that int swap thing above again
	- I don't care they're ints, I want to exchange the REPRESENTATIONS
	- then when I go back to this, the bit patterns are exchanged
	- now when they look at each other, they'll be each other's ints!
- that's the 107 bent, bc it declares a 4-byte figure replicated in that box
- it's REALLY a bit-pattern rotation
- I CANNOT use this to swap doubles

// version of swap that's not constrained to 4 bytes
void swap(void * vp1, void * vp2, int size) {
	// vp1 and vp2 now just point to something starting at generic address
	// void * may be anything, it's NOT meaning this is nothing
	// int size is the number of figures being swapped - this is key info
		// as long as I exchange the byte bit pattern, I'm swapping them
	char buffer[size]; 	// setting aside enough space to hold size bytes
	memcpy(buffer, vp1, size); // like strcpy but no \0, explicit byte size
	memcpy(vp1, vp2, size);  	// replicating over space
	memcpy(vp2, buffer, size); 	// now rotate stuff stored in buffer
}

// the old swap WOULD NOT WORK for generics but "heart is in the right place"
// cannot declare void types and cannot initialize w unknown byte info
void temp = *vp1; 	// void isn't a type, plus we don't know size of vp1
*vp1 = *vp2;
*vp2 = temp; 		// so the rest of this won't work because of above

// ugliness
- problems with using a buffer and mem copy
	char buffer[size]; 	// some C compilers expect buffer size to be a constant

- lots and lots of things can be disguised as void*
 	int x = 17, y = 37;
 	swap(&x,&y,sizeof(int)); 	// OK!

 	double d=Ï€, e=e;
 	swap(&d,&e,sizeof(double)); // called a lot gives copies of code for each type
 	// no compiler errors even though issues arise

- using generics and casts RISKS MORE on runtime, telling compiler not to bother
 	int i = 44;
 	short s = 5;
 	swap(&i,&s,sizeof(short)); 	// mem setup will only accept 2 bytes of short
 	// survives compilation
 	// BUT => short's bits end up in int's left 2 bytes + 44 and 0 alone for s!!

- imagine you did sizeof(int) above instead
 	- possibly worse, as you're grabbing whatever bytes are right of s to swap!

- data types that are already pointers
	char * husband = strdup("Fred"); 	// strdup for indep copies of strings here
	char * wife = strdup("Wilma");

	- in heap |F|r|e|d|\0| and |W|i|l|m|a|\0|
	- but our variables are pointers to those things, they are not those things
	- now I want association from one string to other and vice versa
	swap (&husband,&wife,sizeof(char*));

	- I want to exchange the two things held by husband and wife variables
	- if I want to exchange two char*, I have to pass in addresses to swap
	- if copy address of the char*, happens to be replicated char* material
	- so the pointer addresses are being exchanged, not the values themselves!
	- NOTHING happens to the characters themselves, they stay put!
	- PROBLEM: if you forget to add the address ampersand, will compile
	swap (husband,wife,sizeof(char*));
		- store address of the actual characters (F and W)
		- those characters are evaluated and passed directly to vp1 and vp2
		- copies Wilm\0 and then Freda\0 (size of char* being 4 bytes)
		- worse, that's now the pattern WITHIN the char*, so...
		- we now have a char* husband with an address of Wilm!

- Moral: compiler usually tells you if problem, but NOT with generics

- linear search of first instance of key in array
	// good old homeworky implementation
	int lsearch(int key, int array[], int size) {
		for (int i=0; i<size; i++) {
			if (array[i]==key) {
				return i;
			}
		}
		return -1;
	}
- pay attention to all that's going on in line if(array[i]==key)
	- the array
 	- implicit pointer in array notation
	- bitwise comparison in ==
 	- lose the ability to compare two integers when don't know what they are
- framing a generic version
	- array [             ]
	- i=0 to i=0 advance needs size info about how big elements are
	- manually compute what the addresses are
	- need comparison function to compare key to material in array
		- specify key by address, specify array by address
		- compare the two pointers, actually material at those addresses
		- know the size of each element in the array
		- decide whether or not they match and compare on next iteration

	void *lsearch(void *key, void *base, int n, int elemSize) {
		for(int i=0; i<n; i++) {
			// now compute the address of the ith element
			void *elemAddr = (char*)base + i*elemSize; 	// "the void* hack"
				// seduce base so that we CAN do pointer math here
			 	// fine to assign to void* bc going more to less specific here
				// recall base identifies base address of the entire array
			// now compare elemSize bytes at addresses for dead match
			if (memcmp(key,elemAddr,elemSize)==0) return elemAddr;
				// works for bool, shorts, chars, longs, ints, doubles, floats
				// but DOES NOT work well for character pointers, strings, structs
				// you REALLY should deal with function pointers
		}
		return NULL;
	}

	- the only reason for hack is for compiler to accept void* pointer arithmetic
		- char* because it's 4 bytes long enough to do normal math
		- some people use unsigned longs instead, still for the 4 bytes
	- in array[i] the i is implicitly multiplied by sizeof(int) for you
		- so you're doing some of the compiler's work with (char*)base+i*elemSize
	- *(array+i) 	multiplies behind the scenes by sizeof(int)

	// prototype for another iteration of this function

	void *lsearch (void *key, void *base, int n, int elemSize, int (*cmpfn)(void*, void*)) {
	}
	- 5th parameter has to be a pointer to a function that takes any two void*
	- this comparison function will return 0, 1, -1
	- this is how you use it as a client searching array using generic version


LECTURE 5
