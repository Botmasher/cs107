STANFORD CS107
https://see.stanford.edu/Course/CS107

0. First Day of Class :D
- CS106b/x prereq, looks like lots of compsci problem types/abstractions
- requires lots of C++, first few wks have work cut out for you
- MUST know:
	- arrays
	*- pointers
	- references
	- classes
	*- dynamic memory allocation
	- recursion
	- linked lists
	- binary search trees
	- hashing
	- iterators
	*- function pointers
	- decomposition
- Syllabus (points above) and Resources list on the class page
	- C++, Purify, vi/xemacs, gdb, Scheme

LECTURE 1 6/29/2017
- C
	- imperative paradigm, verb/function-oriented
	- C++ myobject -> dothis (data being manipulated)
	- that's why C++ is object- not function-oriented
	- many people think in C even while C++, sticking w functional not obj
- Assembly
	- show you how a line like j++ translates
	- C++ doesn't execute as C++
	- show how everything compiles to 0s and 1s
	- see how C++ and C almost look the same when compiling
	- gives you idea as to why crashing
- Concurrent
	- we do it in C at the moment
	- all programs prior to 107 have been sequential
	- pipelined/parallel instructions instead of clean streams
	- within a single program, get 2 funcs to (seemingly) run simultaneously
	- tends to switch back and forth so fast can't really see the diff
	- networking in particular, it's very useful
	- however, problems come up (e.g. transactional, shared resources)
	- banks and airlines worried about giving away resources
- Scheme
	- related to Lisp
	- functional paradigm representative
	- 2 things interesting vs C/C++
		- always rely on return value of func to move forward
		- program without side effects
	- such a small language and fun
- Python
	- instead of advanced C++ or Java (108 is all about Java)
	- as "a more modern, object-oriented version of PERL"
	- web programming boring, lots of HMTL, but Python has libraries
	- "great libraries", object-oriented, functional ideas even allowed
	- good vehicle for parsing and protocols
- Next time, low-level pointer stuff!

From the transcript but not in the vid:
- C more difficult but used by longtimers
- by the end you'll be able to read this: **&**P -> ***=7


LECTURE 2
- Low-level mem mechanics, how everything represented 0 1
- C/C++
	- bool, char, short, int, long, float, double
	- short, int, long all rep scalars
	- float and double for arbitrarily precise numbers
 	char 		1 byte
	short 		2 bytes
	int 		4 bytes
	long 		4 bytes
	float 		4 bytes (finite mem tries to do inf precis)
	double 		8 bytes
- binary digit => bit
	- EE think of transistors, hi/lo voltages)
	- CS just think in terms of 2 vals
	- more interesting taken in groups
	- each bit adopts value independently of others
	- therefore 8 bits can distinguish 2**8 values
- chars 
	- epresented in mem backed by some num e.g. A is 65
	- 'A' = 65 but actually some sum of powers of 2 (64+1)
	- 8 is 2**3, etc.
	- looking at all transistors would look like 01000001
	- think of powers of 2 at that position, e.g. 1 at 2**6
- shorts
	- 2 sets of 8 bits separated in 2 boxes
	- contribution of 2 to the whatever again
	- now go up you can get 2 to the 9th, etc. (2 bytes)
	- 0 followed by all 1s is 1 less than 2 to that power
	- 0 to 2**16-1 is range, BUT -2**15 to 2**15-1 instead 
	- the leftmost bit is SIGN not the MAGNITUDE
	- hogs a bit more memory if the second byte is all 0s
	- SIGN BIT: addition/sub use 2'S COMPLEMENT not 1'S C!
		- invert all bits, then add 1 in the 2**0 col!
	- want just as many negs as pos, so leftmost is neg/pos

char ch = 'A';
short s = ch; 	// don't need a cast for that, it's the num
cout << s << endl;
// prints 65 because ch just puts 65 in its bites
// then s has extra byte 0s and a "smear" of 65 in 1st byte

- shorts assigned to a char will punt on the extra byte!

- same thing it init a short as an int
	- just BIT PATTERN copy; remember this is electronics
	- no patience for dealing with the other 2 bytes

short s = -1;
	- tricky representation: 2 bytes all 1s!!
	- this is so you can add to get pos 1
int i = s;
	- NOT simple BIT PATTERN copy like the above cases
	- now the domino effect goes on into the other 2 bytes
	- the other 2 bytes are now full of 1s

- floats
	- 32 bits with a leftmost sign bit
	- think it's 2 to the 30 all the way down to 2 ** 0?
	- NOPE! could use contributions of 2 to negative num?
	- NOPE! instead don't cut it into bytes equally
		- have 1 of 32 bits as sign
		- next 8 bits are unsigned EXPONENT only
		- remaining 23 bits are 2**-1, 2**-2, 2**-3
	- in other words, it's
		(-1)**SIGN (1.xxxxxx * 2 ** exp-127)
	- tries to get dec as close to .999....
	- this is how floats rep in memory

// what happens when assign int to float or float to int
//	- has to evaluate what number the original bit pattern
//	- THEN has to lay out NEW bit pattern in float!
int i = 5;
float f = i;
// lots of 0s followed by 0101 at the end, you know
cout << f << endl;
// you'll get the number 5
// 5.0 totally different bit pattern tho
5 => 5.0 => 1.25*2**2

// can also just evaluate the location of i
int i = 37;
float f = *(float*)&i;
// &i  		we point to the address of i (type int*)
// (float*) we coax into thinking of the SAME bits as float
// * 		we dereference it, getting the value pointed at
// IF PRINTED will just get a really small number
// (because the float is a bunch of right 1s)

float f = 7.0;
short s = *(short*)&f; 	// loc in mem from leftmost spot
// looks similar prob except figures different sizes
// ALWAYS cuts from leftmost point because that's pointer!
// lay them out, you'll see right 2 bytes ignored
// assumes is short, just replicates left bit pattern
// so you just get smear of the left 2 bytes!


LECTURE 3

// clarifying confusion (we understood, some students did not)
double d = 3.1416;
char ch = *(char*)&d;
// the actual bit pattern is irrelevant
// this is an expression on the address of d
// seduced into thinking it's storing the ref of a single char
// pretending to be char for lifetime of char ch statement

short s = 45;
double d = *(double*)&s;
// most still applies, but mysterious:
// &s address assoc c that arrow
// now that thinks pointed to 8-byte double, so
// also assigns the bytes that follow
// byte pattern is 45 + more bytes

- big endian, little endian
	- 2-byte short c a 1 preceded by 0s is true for .5 systems out there
	- in other .5 are little endian, bigger magnitude bytes follow to R!
	- bit copy btwn big e machines to little e machines get difft shorts

// 4 bytes stacked on top of 4 more bytes
// address of entire struct ALWAYS coincident c first field address
// pi. denom on top, pi.num below (pi.num is where arrow points)
// don't know if it's num OR the entire struct that's being pointed
struct fraction {
	int num;
	int denom;
}
fraction pi;
pi.num = 22; 	// places 22 at 0 offset from base of entire struct
pi.denom = 7; 	// places 7 at 4 bytes above base of struct
// knows that denom is 4 bytes above the address of the num

/*
 * NOW INVADE pi.denom's space using QUIRKY SYNTAX
 * 	- change it's value using references
 */
&(pi.denom) 			// gets an int*
(fraction*)&(pi.denom)	// gets address of pi.denom as if it's fraction*
// arrow travels to struct and identifies num as place that should receive 12
((fraction*)&(pi.denom))->num = 12;
// travel to fraction struct and identify num field to receive the 12
// this replaces pi.denom from 7 to 12 "behind pi.denom's back"!

// now we smear the bytes above pi.denom with 33
// even though no way of legally accessing this because stored above struct
((fraction*)&(pi.denom))->denom = 33;

// note that to access this now you'd workaroudn to get back to those bytes
((fraction*)&(pi.denom))[0].denom;

- array is COMPLETELY synonymous with ADDRESS of the ZEROTH ENTRY
int array[10];
array[0] = 44;
array[9] = 100;
array[5] = 45;
array[11] = 1; 		// might succeed or crash based on touching local vars
					// NOT because of bounce checking
// THEOREM: array <-> &array[0]
// NO bounce checking on raw arrays, so array[11]=1 tries to place 1!!
// same with array[-4]=77

// THEOREM: array+k <-> &array[k]
// you're doing pointer arithmetic, the boundaries between ints
// k automatically scaled based on the type system (e.g. int 4 bytes wide)

// THEOREM: *array <-> array[0]
// THEOREM: *(array+k) <-> array[k]
*(array-4) = 77; 	// brings you 16 bytes before

int arr[5];
arr[3]=128; 		// bits fit and updated in right half of box 3
(short*)arr; 		// now thinks arr stores shorts
(short*) arr[6]=2; 	// writes a 2 in the left half of index 3's bytes!!
cout << arr[3] << endl; 	// prints out both left and right bits!

((short*)(((char*)(&arr[1])+8))[3]=100; 	// writes 100 way after array

- in C we don't write generics, we leverage the fact we know
	- size of everything
	- and bit pattern of everything

// 16 byte struct
struct student{
	// no string class in C++, so char arrays ending with null char
	char* name; 	// store address of zeroth char
	char suid[8]; 	// 2x 4 array blocks above name
	int numUnits; 	// int bytes above suid blocks
}
// now lay out 4 student structs side by side (like array)
student pupils[4];
pupils[0].numUnits=21; 	// 21 goes in topmost field of zeroth struct
// dynamically alloc enough space for "Adam" then returns addr of "A"
// makes enough space for \0 (end character)
pupils[2].name = strdup("Adam");

// NOW do some funkiness using those structs
pupils[3].name = pupils[0].suid+6; 	// do pointer arithmetic agst a char*
// strcpy just sees 
strcpy(pupils[1].suid, "40415xx"); 		// copy characters to suid
	// make SURE that it's char address under your jurisdiction - was fine
strcpy(pupils[3].name, "123456"); 		// copy characters to field
	// was NOT fine - [3]'s.name pointer changed above, so now
	// we're writing into pupils[0].suid+6 !!!!!
	// better make sure you own that mem if you're writing char or whatever
pupils[7].suid[11]='A'; 			// still does manual arithm to find!

- free up memory using FREE (like DELETE in other lang)
- if print out chars in char array from an index, prints all chars to right
	- final /0 doesn't print out 'naccount of being weird rep of empty string

// bit pattern swapping
void swap(int *ap, int *bp)
{
	// I know that ap and bp are just pointers to x box and y box
	int temp = *ap;
	// temp is now smeared with whatever the value of ap is
	*ap = *bp; 	// space addressed by ap is now set to what bp evaluates to
	*bp = temp; // achieve the swap
}
int x=7;
int y=117;
// C has no templates and no references, just addresses
// knows where to go to move byte patterns around
swap(&x,&y);

- in other langs we'd templatize (generic)
 	- see we can do swaps, etc. using info learned last 2 lectures
 	- it's not hacky, it's beautiful


LECTURE 4

