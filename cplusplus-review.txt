// http://www.cplusplus.com/doc/tutorial/


// sample program to add two numbers
00000	10011110
00001	11110100
00010	10011110
00011	11010100
00100	10111111
00101	00000000

// same program in C++ to compile
int a, b, sum;
     
cin >> a;
cin >> b;
             
sum = a + b;
cout << sum << endl;


/*
 * 	Example program anatomy
 */

#include <iostream> 			// preprocessor directive (here: include standard i/o ops)
								// blank line
int main() 						// function declaration; "main" is special in C++
{
  std::cout << "Hello World!"; 	// print to screen using character out; << is the insertion op
}

// same output but introducing namespace visibility to allow for unqualified cout
#include <iostream>
using namespace std;
int main() { cout << "Hello World!"; }


/*
 * 	Variables
 */

// Fundamental types (see below for compound types like strings)
char s 					// at least 8 bits
char 16_t s 			// at least 16 bits
char 32_t s 			// at least 32 bits
wchar_t s 				// largest supported char set
signed char x 			// at least 8 bits
signed short int x 	 	// at least 16 bits
signed int x 			// at least 16 bits
signed long int x 		// at least 32 bits
signed long long int x 	// at least 64 bits
unsigned... 			// for ints, same as signed counterparts
float
double
long double
bool
void
decltype(nullptr) 		// null pointer

// c-like vs constructor vs uniform initialization
int x = 0;
int x (0);
int x {0};

// Type deduction
auto y = x; 		// y deduced to be int
decltype(x) y; 		// y deduced to be int

// Compound types like strings
#include <iostream>
#include <string> 				// include preprocessor directive
int main () {
	string s = "my text"; 		// initialize
	std::cout << s  << endl; 	// endl manipulator prints newline and flushes stream
}

// Constants
75
0113 	// 75 in octal
0x4b 	// 75 in hex
75u 	// unsigned suffix
75l 	// long suffix
75ul 	// unsigned long suffix
75lu 	// unsigned long suffix
6.02f 	// float
3.14L 	// long
'c' 	// character literal
"char" 	// string literal
const double pi = 3.14 	// convenient way to set and use a const instead of literal

#define PI 3.14 		// preprocessor definitions for const instead
#define NEWLINE '\n' 	// identifier -> replacement (#define IDENTIFIER REPLACEMENT)

// operators
y = 2 + (x=3); 	// assignment operations can be evaluated
++x;
x+=1;

// relational and comparison operators 	== != > < >= <=

// logical operators 	! || &&

// ternary ?

// comma for multiple assignment ,

// bitwise & | ^ ~ << >>

// explicit type casting
int i = (int) 3.14;

// get size of one type or one variable in bytes
x = sizeof (char);

// standard io
#include <iostream>
using namespace std;
int main () {
	int age;
	cin >> age;
	cout << age << endl;
}

// io treat string as stream
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
int main () {
	// separate process of getting input from interpreting data
	string s;
	int age;
	int year;
	cout << "Your age: ";
	getline (cin,s);
	stringstream (s) >> age;
	cout << "Year: ";
	getline (cin,s);
	stringstream (s) >> year;
	cout << "It is " << year << " and you are " << age << endl;
	return 0;
}

/*
 * 	Statements and flow control
 */
// indentation and line breaks no effect
if (x) { cout << "Value: "; cout << x; }

// branches
if (x)
	cout << x;
else
	cout << "not x";

// while and do while loops
while (x < 100) {}
do {} while (x != 100)

// for loops; all semicolons required even blank
// terminology:
// 		for (INITIALIZATION; CONDITION; INCREASE) {}
for (int n=0; n>0; --n) {}
for (;n>0;) {}
for (n=0, i=10; n!=i; ++n, --i) {}

// range-based for loop
// 		for ( declaration : range ) statement;
for (char c : string ) {}

// break and continue "jump" statements

// goto "jump" statement: identify a label and then goto
// 	/!\ unconditional jump, ignores nesting, no auto stack unwinding
int main () {
	int n = 3;
newlabel:
	--n;
	if (n>0) goto newlabel;
}

// switch case
switch (x) {
	case 1:
	case 2:
	case 3:
		break;
	default:
		cout << "x!"
}


/*
 * 	Functions
 */
// main() is the only function called automatically
// all other funcs exec from main
int add (int a, int b) {
	int res;
	res = a + b;
	return res;
}
int main() {
	int z = 4 + add (5, 3);
	cout << z << endl;
}

// return 0 is implicit in main(), though some programmers prefer explicit
int main () {
	return 0;
}

// calling functions w params taken by values causes copies of values to be made
// passing by reference no longer does copy but var itself!
void duplicate (int& a) {
	a*=2;
}

int main() {
	int x = 1;
	duplicate (x);
	cout << x << endl;
	return 0;
}


// to make sure that ref vars not modified, make the params constant
int add (const int& a, const int& b) {
	return a+b;
}
// extremely popular for compound types (e.g. string)
// extremely efficient for params of compound types


// use INLINE to tell compiler to insert the statements inline
// instead of using function overhead like stacked arguments, jumps, ...
inline string concatenate (const string& x, const string& y) {
	return x+y;
}
// done automatically in some compilers when they see efficiency gain anyhow

// default val
int integerstuff (int x=0) {}

// declaring prototype of a function (define it somewhere else in code)
int prototype (int, int); 	// notice that param names not needed but types are
// useful in cases where functions required before defined, e.g. mutual checks

// recursivity
long factorial (long a) {
	if (a > 1)
		return (a * factorial (a-1));
	else
		return 1;
}

// overloaded functions
int add (int a, int b) {
	return (a+b);
}
double add (double a, double b) {
	return (a+b);
}

// template types using CLASS or TYPENAME (synonymous)
template <class SomeType>
SomeType add (SomeType a, SomeType b) {
	return a+b;
}

// template arguments
template <typename T>
T add (T a, T b) {
	T sum = a+b; 	// notice local var of type T
	return sum;
}
// then when called in main()
add<int> (x,y);


// compile time not run time for template params!
template <class T, int N>
T fixed_mult (T val) {
	return val * N;
}
// therefore second template arg must be constant here
int main() {
	fixed_mult<int,2> (3); 	// creates func that ALWAYS multiplies by 2
							// and then passes it in a 3
}

// visibility, local scope until end of block, namespaces
// namespace identifier { named_entities }
namespace myInts {
	int a,b;
}
myInts::a;

// declaring multiple segments in the same namespace
namespace a { int a; }
namespace b { int b; }
namespace a { int b; }

// using keyword for namespaces
using namespace a;

// or in main()
int main() {
	using namespace a;
}

// global and namespace vars allocated for duration of program
// STATIC vars vs AUTOMATIC storage for local vars
	// AUTOMATIC only avail in block in which declared; after that mem can be used for other
	// non-explicit STATIC initialize to 0
	// non-explicit AUTOMATIC do not initialize


// Arrays as contiguous mem loc using same identifier and proper index
int a [4] = { 1, 77759, 22, 6 };
// empty brackets when initialization vals present
int a [] = { 1, 77759, 22, 6 };
int x = a[2];

// multid arrays
char dimensions [3][10];

// arrays as params
void myfunc (int arg[]); 	// omit the size

// container library arrays
#include <iostream>
#include <array>
int main() {
	array<int, 2> a { 0, 1200 };
	int size = a.size();
	int zeroth = a[0];
	for (int e : a)
		std::cout << e << endl;
}


// character sequences - up to n elements and end in \0 character
char word[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
word[1]; 	// => 'e'

// string literals
char word[] = "Hello"; 	// actually regular array w \0 appended automatically

// cin and cout support null-terminated sequences directly
cout << "Hello";

// transforming into strings implicitly
char c[] = "text";
string s = "asdf";
s = c;
cout << s; 	// => "asdf"

/*
 *	Pointers
 * 
 * sequential, unique physical addresses for each cell in memory
 * generally, OS not C++ decides particular locations in runtime
 * C++ can obtain address
 */

// address-of operator
y = x; 			// value (content) of x
y = &x; 		// location of x

// dereference
val_x = *y; 	// store the content of x (set var equal to value pointed to by y)
// note that *y and y are NOT the same
// * and & are complementary
*y == x; 		// will be true above

// declaring a pointer: type * name
int * num; 	// asterisk indicates it is a pointer
char * c;

// declaring multiple pointers requires multiple *
int * x1, * x2; 		// both are pointers
int * x1, x2; 			// x1 is pointer, x2 just int!

// arrays are like pointers to their first element
int a[5];
int* p;

// main diff is pointers assigned new address, arrays cannot
p = a; 		// valid assigment - can assign a different address
a = p; 		// invalid assigment because array is always same block of 5 int

// both valid and equivalent expressions
a[5] = 0;
*(a+5) = 0;

// pointer arithmetic
// only addition and subtraction
char *c;
++c; 		// points to the next location in memory of a character
			// the size of a char in bytes (1) is thus added to pointer
long *l;
++l; 		// points to the next location in memory of a long
			// the size of a long in bytes (4) is thus added to pointer

// these are identical to above
c = c + 1;
l = l + 1;

// dereference with pointer arithmetic
*p++; 	 	// increments pointer but dereferences original address
		// note that postfix ++ increments separately from dereferencing
*(p++); 	// same as above
*++p; 		// dereferences incremented address, same as *(++p)
++*p; 		// increment the value of the pointer
(*p)++; 	// post-increment the value of the pointer (so that increments last)

// given above, point p to q and THEN increment both values
*p++ = *q++;


// pointer & const
int x;
int y;
const int * p = &y;
x = *p; 	// ok
*p = x; 	// error

int x;
int * p1 = &x; 		
const int * p2a = &x; 		// const pointer to int
int const * p2b = &x; 		// same, const pointer to int
int * const p3 = &x; 		// pointer to const int
const int * const p4 = &x;

// pointer & string literal
const char * s = "hello";
	// now points to first element of char array |'h'|'e'|'l'|'l'|'o'|'\0'|

s[2] 	// since pointers and arrays behave basically same
*(s+2)  // since pointers and arrays behave basically same

// pointers to pointers
// syntax: asterisk "for each level of indirection in the declaration"
char c;
char * cp;
char ** cpp; 	// cpp is of type char **
c = 'a';
cp = &c;
cpp = &cp;
 	// result: cpp box contains cp's address, cp contains c's address, c contains 'a'

// void pointers
void * data; 		// just point to any data type, doesn't grab fixed # blocks
// CANNOT be directly dereferenced ( since they have no type )
// SO must convert to concrete data type to deref
// used to handle generics in methods

// invalid and null pointers
int * p;			// not initialized to any value
int a[9];
int * q = a+10; 	// out of bounds but NOT error
	// no errors here - pointers can point to any address
	// DEREFERENCING such a pointer will cause a problem, however

// point to nowhere
int * p = 0;
int * q = nullptr; 	// compares equal to 0
int * r = NULL; 	// constant in older code
	// don't confuse with void, which can point somewhere without type!

// function pointer - usu for passing as arg to another function
int operation (int x, int y, int (*func)(int,int)) {
	int calc = (*func)(x,y);
	return (calc);
}

// passing around and assigning a function
int subtraction (int a, int b) { return (a-b); }
int minus (int, int) = subtraction;