// http://www.cplusplus.com/doc/tutorial/


// sample program to add two numbers
00000	10011110
00001	11110100
00010	10011110
00011	11010100
00100	10111111
00101	00000000

// same program in C++ to compile
int a, b, sum;
     
cin >> a;
cin >> b;
             
sum = a + b;
cout << sum << endl;


/*
 * 	Example program anatomy
 */

#include <iostream> 			// preprocessor directive (here: include standard i/o ops)
								// blank line
int main() 						// function declaration; "main" is special in C++
{
  std::cout << "Hello World!"; 	// print to screen using character out; << is the insertion op
}

// same output but introducing namespace visibility to allow for unqualified cout
#include <iostream>
using namespace std;
int main() { cout << "Hello World!"; }


/*
 * 	Variables
 */

// Fundamental types (see below for compound types like strings)
char s 					// at least 8 bits
char 16_t s 			// at least 16 bits
char 32_t s 			// at least 32 bits
wchar_t s 				// largest supported char set
signed char x 			// at least 8 bits
signed short int x 	 	// at least 16 bits
signed int x 			// at least 16 bits
signed long int x 		// at least 32 bits
signed long long int x 	// at least 64 bits
unsigned... 			// for ints, same as signed counterparts
float
double
long double
bool
void
decltype(nullptr) 		// null pointer

// c-like vs constructor vs uniform initialization
int x = 0;
int x (0);
int x {0};

// Type deduction
auto y = x; 		// y deduced to be int
decltype(x) y; 		// y deduced to be int

// Compound types like strings
#include <iostream>
#include <string> 				// include preprocessor directive
int main () {
	string s = "my text"; 		// initialize
	std::cout << s  << endl; 	// endl manipulator prints newline and flushes stream
}

// Constants
75
0113 	// 75 in octal
0x4b 	// 75 in hex
75u 	// unsigned suffix
75l 	// long suffix
75ul 	// unsigned long suffix
75lu 	// unsigned long suffix
6.02f 	// float
3.14L 	// long
'c' 	// character literal
"char" 	// string literal
const double pi = 3.14 	// convenient way to set and use a const instead of literal

#define PI 3.14 		// preprocessor definitions for const instead
#define NEWLINE '\n' 	// identifier -> replacement (#define IDENTIFIER REPLACEMENT)

// operators
y = 2 + (x=3); 	// assignment operations can be evaluated
++x;
x+=1;

// relational and comparison operators 	== != > < >= <=

// logical operators 	! || &&

// ternary ?

// comma for multiple assignment ,

// bitwise & | ^ ~ << >>

// explicit type casting
int i = (int) 3.14;

// get size of one type or one variable in bytes
x = sizeof (char);

// standard io
#include <iostream>
using namespace std;
int main () {
	int age;
	cin >> age;
	cout << age << endl;
}

// io treat string as stream
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
int main () {
	// separate process of getting input from interpreting data
	string s;
	int age;
	int year;
	cout << "Your age: ";
	getline (cin,s);
	stringstream (s) >> age;
	cout << "Year: ";
	getline (cin,s);
	stringstream (s) >> year;
	cout << "It is " << year << " and you are " << age << endl;
	return 0;
}

/*
 * 	Statements and flow control
 */
// indentation and line breaks no effect
if (x) { cout << "Value: "; cout << x; }

// branches
if (x)
	cout << x;
else
	cout << "not x";

// while and do while loops
while (x < 100) {}
do {} while (x != 100)

// for loops; all semicolons required even blank
// terminology:
// 		for (INITIALIZATION; CONDITION; INCREASE) {}
for (int n=0; n>0; --n) {}
for (;n>0;) {}
for (n=0, i=10; n!=i; ++n, --i) {}

// range-based for loop
// 		for ( declaration : range ) statement;
for (char c : string ) {}

// break and continue "jump" statements

// goto "jump" statement: identify a label and then goto
// 	/!\ unconditional jump, ignores nesting, no auto stack unwinding
int main () {
	int n = 3;
newlabel:
	--n;
	if (n>0) goto newlabel;
}

// switch case
switch (x) {
	case 1:
	case 2:
	case 3:
		break;
	default:
		cout << "x!"
}


/*
 * 	Functions
 */
// main() is the only function called automatically
// all other funcs exec from main
int add (int a, int b) {
	int res;
	res = a + b;
	return res;
}
int main() {
	int z = 4 + add (5, 3);
	cout << z << endl;
}

// return 0 is implicit in main(), though some programmers prefer explicit
int main () {
	return 0;
}

// calling functions w params taken by values causes copies of values to be made
// passing by reference no longer does copy but var itself!
void duplicate (int& a) {
	a*=2;
}

int main() {
	int x = 1;
	duplicate (x);
	cout << x << endl;
	return 0;
}


// to make sure that ref vars not modified, make the params constant
int add (const int& a, const int& b) {
	return a+b;
}
// extremely popular for compound types (e.g. string)
// extremely efficient for params of compound types


// use INLINE to tell compiler to insert the statements inline
// instead of using function overhead like stacked arguments, jumps, ...
inline string concatenate (const string& x, const string& y) {
	return x+y;
}
// done automatically in some compilers when they see efficiency gain anyhow

// default val
int integerstuff (int x=0) {}

// declaring prototype of a function (define it somewhere else in code)
int prototype (int, int); 	// notice that param names not needed but types are
// useful in cases where functions required before defined, e.g. mutual checks

// recursivity
long factorial (long a) {
	if (a > 1)
		return (a * factorial (a-1));
	else
		return 1;
}

// overloaded functions
int add (int a, int b) {
	return (a+b);
}
double add (double a, double b) {
	return (a+b);
}

// template types using CLASS or TYPENAME (synonymous)
template <class SomeType>
SomeType add (SomeType a, SomeType b) {
	return a+b;
}

// template arguments
template <typename T>
T add (T a, T b) {
	T sum = a+b; 	// notice local var of type T
	return sum;
}
// then when called in main()
add<int> (x,y);


// compile time not run time for template params!
template <class T, int N>
T fixed_mult (T val) {
	return val * N;
}
// therefore second template arg must be constant here
int main() {
	fixed_mult<int,2> (3); 	// creates func that ALWAYS multiplies by 2
							// and then passes it in a 3
}

// visibility, local scope until end of block, namespaces
// namespace identifier { named_entities }
namespace myInts {
	int a,b;
}
myInts::a;

// declaring multiple segments in the same namespace
namespace a { int a; }
namespace b { int b; }
namespace a { int b; }

// using keyword for namespaces
using namespace a;

// or in main()
int main() {
	using namespace a;
}

// global and namespace vars allocated for duration of program
// STATIC vars vs AUTOMATIC storage for local vars
	// AUTOMATIC only avail in block in which declared; after that mem can be used for other
	// non-explicit STATIC initialize to 0
	// non-explicit AUTOMATIC do not initialize


// Arrays as contiguous mem loc using same identifier and proper index
int a [4] = { 1, 77759, 22, 6 };
// empty brackets when initialization vals present
int a [] = { 1, 77759, 22, 6 };
int x = a[2];

// multid arrays
char dimensions [3][10];

// arrays as params
void myfunc (int arg[]); 	// omit the size

// container library arrays
#include <iostream>
#include <array>
int main() {
	array<int, 2> a { 0, 1200 };
	int size = a.size();
	int zeroth = a[0];
	for (int e : a)
		std::cout << e << endl;
}


// character sequences - up to n elements and end in \0 character
char word[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
word[1]; 	// => 'e'

// string literals
char word[] = "Hello"; 	// actually regular array w \0 appended automatically

// cin and cout support null-terminated sequences directly
cout << "Hello";

// transforming into strings implicitly
char c[] = "text";
string s = "asdf";
s = c;
cout << s; 	// => "asdf"

/*
 *	Pointers
 * 
 * sequential, unique physical addresses for each cell in memory
 * generally, OS not C++ decides particular locations in runtime
 * C++ can obtain address
 */

// address-of operator
y = x; 			// value (content) of x
y = &x; 		// location of x

// dereference
val_x = *y; 	// store the content of x (set var equal to value pointed to by y)
// note that *y and y are NOT the same
// * and & are complementary
*y == x; 		// will be true above

// declaring a pointer: type * name
int * num; 	// asterisk indicates it is a pointer
char * c;

// declaring multiple pointers requires multiple *
int * x1, * x2; 		// both are pointers
int * x1, x2; 			// x1 is pointer, x2 just int!

// arrays are like pointers to their first element
int a[5];
int* p;

// main diff is pointers assigned new address, arrays cannot
p = a; 		// valid assigment - can assign a different address
a = p; 		// invalid assigment because array is always same block of 5 int

// both valid and equivalent expressions
a[5] = 0;
*(a+5) = 0;

// pointer arithmetic
// only addition and subtraction
char *c;
++c; 		// points to the next location in memory of a character
			// the size of a char in bytes (1) is thus added to pointer
long *l;
++l; 		// points to the next location in memory of a long
			// the size of a long in bytes (4) is thus added to pointer

// these are identical to above
c = c + 1;
l = l + 1;

// dereference with pointer arithmetic
*p++; 	 	// increments pointer but dereferences original address
		// note that postfix ++ increments separately from dereferencing
*(p++); 	// same as above
*++p; 		// dereferences incremented address, same as *(++p)
++*p; 		// increment the value of the pointer
(*p)++; 	// post-increment the value of the pointer (so that increments last)

// given above, point p to q and THEN increment both values
*p++ = *q++;


// pointer & const
int x;
int y;
const int * p = &y;
x = *p; 	// ok
*p = x; 	// error

int x;
int * p1 = &x; 		
const int * p2a = &x; 		// const pointer to int
int const * p2b = &x; 		// same, const pointer to int
int * const p3 = &x; 		// pointer to const int
const int * const p4 = &x;

// pointer & string literal
const char * s = "hello";
	// now points to first element of char array |'h'|'e'|'l'|'l'|'o'|'\0'|

s[2] 	// since pointers and arrays behave basically same
*(s+2)  // since pointers and arrays behave basically same

// pointers to pointers
// syntax: asterisk "for each level of indirection in the declaration"
char c;
char * cp;
char ** cpp; 	// cpp is of type char **
c = 'a';
cp = &c;
cpp = &cp;
 	// result: cpp box contains cp's address, cp contains c's address, c contains 'a'

// void pointers
void * data; 		// just point to any data type, doesn't grab fixed # blocks
// CANNOT be directly dereferenced ( since they have no type )
// SO must convert to concrete data type to deref
// used to handle generics in methods

// invalid and null pointers
int * p;			// not initialized to any value
int a[9];
int * q = a+10; 	// out of bounds but NOT error
	// no errors here - pointers can point to any address
	// DEREFERENCING such a pointer will cause a problem, however

// point to nowhere
int * p = 0;
int * q = nullptr; 	// compares equal to 0
int * r = NULL; 	// constant in older code
	// don't confuse with void, which can point somewhere without type!

// function pointer - usu for passing as arg to another function
int operation (int x, int y, int (*func)(int,int)) {
	int calc = (*func)(x,y);
	return (calc);
}

// passing around and assigning a function
int subtraction (int, int);
int subtraction (int a, int b) { return (a-b); }
int minus (int, int) = subtraction;

/*
 * Dynamic memory
 * for when mem needs must be determined at runtime
 */

// new, SYNTAX: pointer = new type;
// new[], SYNTAX: pointer = new type[number of elements];
int x = new int[5];
	// allocates space for 5 ints and returns pointer to first int
	// x is now a pointer to zeroth element, so x[1] and *(x+1) both work as expected

// BIG differences between new and normal declaration
int x[5]; 				// needs constant expression determined when designing program
int x = new int[5]; 	// dynamic memory allocated during runtime with any variable as size

// allocated by system from heap; NO GUARANTEE that new is successful
x = new int[5]; 			// if alloc fails => exception of type bad_alloc
x = new (nothrow) int [5]; 	// nothrow object as arg for new, now can check for nullptr
if (x == nullptr) {}
	// exception generally preferred though, since less efficient to check nullptr explicitly

// operators delete and delete[]
// since dynamic mem only needed during specific times in program
delete pointer; 	// releases mem of a single element allocated using new keyword
delete[] pointer; 	// releases mem allocated for arrays using new keyword
	// argument to delete must be either pointer or block alloc by new OR a nullptr
	// if it's a case of nullptr, works but produces no effect

// variables and inability to allocate
int * a = new (nowthrow) int[i];
	// user could pass value for i too big for system to allocate
if (p == nullptr) { cout << "Error: memory could not be allocated"; }

// C language memory blocks
malloc, calloc, realloc, free 	// blocks allocated by these funcs not compatible with new
	// avail in C++ but do not mix with new/delete because each handled by own funcs or operators

/*
 * Data Structures
 */
struct type_name {
	member_type1 member_name1;
	member_type2 member_name2;
} object_names;

// sample implementation
// many objects declarable from single structure type
struct product {
	double price;
	int weight;
} ;
product strawberry;
product banana;

// or also
struct product {
	double price;
	int weight;
} strawberry, banana;

// dot syntax between object name and member name
strawberry.weight; 	// of type int

// objects are also variables of type (here of type product)
// construct databases of structs using them as type of arrays
struct type_name {
	member_type1 member_name1;
} object_name [n];

// point to struct using own type of pointer
product * banana_pointer = &banana;
	// the value is the address of banana

// arrow -> is dereference op specifically for struct members
banana_pointer->price;
(*banana_pointer).price; 	// essentially equivalent for our purposes

// careful because this is different!
*banana_pointer.price;
 	// should == *(banana_pointer.price) which expects price to be a pointer!

a.b == (*&a).b;
a->b == (*a).b;
*a.b == *(a.b);

// nested structures
struct stores {
	string name;
	product sale_product;
} my_local_store;

stores * current_store = &my_local_store;

// now all the following are valid
my_local_store.name;
my_local_store.sale_product.price;
current_store->sale_product.weight;

// Type Aliases provide abstraction or avoid long/confusing names
typedef char C; 	// syntax: typedef existing_type new_type_name;
typedef unsigned int WORD;
typedef char * pC;
typedef char text_field [50];

text_field txt;
pC char_array;

// more recent C++
using C = char;

// Unions
	// identified by type_name occupy same phys space in mem
union type_name {
	member_type1 member_name1;
	member_type2 member_name2;
} object_names;

// Unions often used to access all or part of value stored in mem blocks
union mix_t {
	int l;
	struct {
		short hi;
		short lo;
	} s;
	char c[4];
} mix;

// mix.l, mix.s, mix.c give us access to same 4 bytes, but can access as if difft types
	// (one int, two shorts, one char array)
	// in little-endian systems, the .hi and c[0] are leftmost

// Anonymous unions used with struct
struct book1_t {
	char title [50];
	char author [50];
	union {
		float dollars;
		int yen;
	} price;
} book1;
book1.price.yen; // access the yen from named union

struct book2_t {
	char title [50];
	char author [50];
	union {
		float dollars;
		int yen;
	} ;
} book2;
book2.yen; 		// access the yen from anonymous union
	// /!\ yen and dollars occupy same place in mem, so one or other set but not both

// Enum, mebers of which are implicitly convertible to ints 
enum colors_t {black=1, white, red, blue, green}; 	// set to count from 1
colors_t my_color;
my_color = blue;

// Enum types with enum class
enum class Colors {black, white, red, blue, green};
Colors color;
color = Colors::blue;	// enumerator vals must each be scoped into its own type

// control over type of enum class
enum class HairColor : char { brown, black, blond, white, other };
	// HairColor has distinct type of same size as char


/*
 *	Classes
 */

class cname {
	access_specifier1: member1;
	access_specifier2: member2;
} object_names;

// same as other structures except they include functions and access specifiers
class Rect {		// most importantly, this makes a type
		int w, h; 	// private access
	public:
		void set_values (int,int);	// not inline, defined outside
		int area() {return (w*h);}
};
void Rect::set_values(int x, int y) { 	// scope operator ::
	w = x;
	h = y;
}
int main () {
	Rect sq;
	sq.set.values (2,2);
	cout << "Area: " << sq.area();
}

// Constructors
	// what if we called area before set_values? wouldn't work
	// pass important arguments to initialize only once
	// they never return values though, only initialize
class Rect {	
		int w, h;
	public:
		Rect (int,int); 	// constructor
		int area() {return (w*h);}
};

// now in main () we pass those when objs of class created
Rect r1 (1,3);
Rect r2 (20,6);

// overloaded constructors
Rect::Rect () { 	// default constructor, no params
	w = 5;
	h = 5;
}
Rect::Rect (int x) {
	w = x;
	h = x;
}
Rect::Rect (int x, int y) {
	w = x;
	h = y;
}

// Uniform initialization
Rect r_assignment = 1; 		// variable initialization syntax (ONLY constructors of single param)
Rect r_functional (1,2);	// functional form
Rect r_default;				// use default constructor
Rect r_uniform {1,2}; 		// newer uniform init
	// functional as most common
	// uniform has potential pitfalls of using initializer_list

// Members initialized in constructors
class Rect {
		int w,h;
	public:
		Rect(int,int);
		int area() {return(w*h);}
}
// usual definition of constructor
Rect::Rect (int x, int y) { w=x; h=y; };
// member initialization
Rect::Rect (int x, int y) : w(x) { h=y; }
// or even do nothing but initialize members
Rect::Rect (int x, int y) : w(x), h(y) {}

// this works for fundamental types after colon; class members just init as default constructor
	// may or may not be convenient
	// if default constr not possible, members init in member init list

// pointer to class
Rect *rp;

// pointed-to class members accessed using arrow op
rp->area();

// pointer ops with objects and members
*x; 		// pointed to by x
&x; 		// address of x
x.y; 		// member y of object x
x->y; 		// member y of object pointed to by x
(*x).y; 	// member y of object pointed to by x
x[n]; 		// nth obj pointed to by x

// struct also used for classes
 	// ONLY diff as that class members private by default, struct public
 	// union also public, but behave diff as noted above

// overloadable class operators
struct product {
	string name;
	float price;
} a, b, c;
a=b+c; 	// will just not compile bc + behavior not defined for these types

// use operator functions to overload them
type operator sign (parameters) { /* body */ }
class CartesianVector {
	public:
		int x,y;
		CartesianVector() {};
		CartesianVector(int a, int b) : x(a), y(b) {}
		CartesianVector operator + (const CartesianVector&); 	// constructor function returns CVector
			// operator+ here overloads op to take type as rhs operand
};

// overload as non-member func instead (above was as member function)
	// only some operators; pass object of proper class as first arg
CartesianVector operator+ (const CartesianVector& lhs, const CartesianVector& rhs)
{
	CartesianVector temp;
	temp.x = lhs.x + rhs.x;
	temp.y = lhs.y + rhs.y;
	return temp;
}
	// now when add two CVects you get a new vector with result (x,y) added properly

// "this" keyword
	// within function pointer to object whose member func is being executed
class Itself {
	public:
		bool itsme (Itself&);
}
bool Itself::itsme (Itself& x)
{
	if (&x==this) return true;
	return false;
}

// this used within operator= def
CartesianVector& CartesianVector::operator= (const CartesianVector& param)
{
	// similar to what compiler generates implicitly for operator= for this class!
	x=param.x; 		// me: equiv to this.x and this.y?
	y=param.y;
	return *this;
}

// static data or functions
class Something {
	public:
		static int n;
		Something () { n++; }
}
int Something::n=0; 	// same props as non-members but have class scope
// must be init outside class, not inside it (to avoid multiple decl)
// can be ref by any obj of that class
Something a;
Something b[2];
cout << a.n;

// can also be ref through class name directly
cout << Something::n;

// constant obj
const Something sth;
// constant member funcs - access is read-only, though constructor still mods
// member funcs only called if spec as const members
int const get() { return x; }
	// sth.get() would not be callable if not specified as const
// /!\ keep syntax different from const return type!
const int& get () { return x; }

// /!\ const member funcs CANNOT modify non-static data or call non-const funcs

// NOT uncommon or unwieldy; most funcs taking objects actually take const objs!
	// so can call const member functions without modifying data of obj

// can overload a func, one const one not
class AnotherThing {
		int x;
	public:
		AnotherThing(int val) : x(val) {}
		const int& get () const { return x; }
		int& get () { return x; }
}
// then in main()
AnotherThing th1 (2);
AnotherThing th2 (10);
th1.get() = 10; 	// valid because returns int&
th2.get() = 2; 		// invalid because returns const int&

// class templates
template <class T>
class mypair {
		T values [2];
	public:
		mypair (T first, T second) {
			values[0]= first; values[1]=second;
		}
};
// above stores values of any valid type
mypair<int> myobj (100, 2); 		// or mypair<double> myobj (100.1, 2.7589);

// member func declared outside (not inline like constructor above)
template <class T> 			// <class T> for class template parameter
T mypair<T>::getmax () 		// T for return type, <T> for func templ param
{
	T maxval;
	maxval = a>b? a : b;
	return maxval;
}

// template specialization for when spec type passed into template
template <class T>				// generic template
class myclasstemplate {
		T element;
	public:
		myclasstemplate (T arg) { element=arg; }
		T increase () { return ++element; }
};
template <> 					// specialization; empty param list since all types known
class myclasstemplate <char> {
		char element;
	public:
		myclasstemplate (char arg) { element=arg; }
		char uppercase() {
			...
		}
};

// default constructor
class Example {
	public:
		int val;
		void accumulate (int x) { total += x; }
};

Example ex; 	// do not need an explicit constructor for 0 params
	// BUT once explicit constructor declared, replaces default constructor
	// so the compiler does not supply one automatically (one that takes 0 args)

// default constructor essentially looks like this
Example () {}

// Destructor for cleanup when class lifetime ends
	// used e.g. to release memory from dynamic memory alloc
class Example {
		string* p;
	public:
		// CONSTRUCTOR functions allocate dynamic memory to store string
		Example() : p(new string) {}
		Example (const string& s) : p(new string(str)) {}
		// DESTRUCTOR function
		~Example () { delete p; }
		const string& content() const { return *p; }
}

int main () {
	Example ex0;
	Example ex1 ("example");

	std.cout << "ex1 content: " << ex1.content() << '\n';
	return 0;
}

// copy constructor
	// invoked when passing name of own-type obj to an obj as arg
MyClass::MyClass (const MyClass&);

// implicit copy just performs copy of all members
class MyClass {
	public:
		int a, b; string c;
};

// shallow copy is about equivalent to this syntax
MyClass::MyClass(const MyClass& x) : a(x.a), b(x.b), c(x.c) {}

// shallow copy may not be appropriate when dealing with pointers
	// mult obj will have members still pointing to e.g. same string
	// following custom copy constructor does deep copy
// "custom copy constructor"
class Example {
		string *p;
	public:
		// constructor
		Example (const string& s) : p(new string(s)) {};
		// destructor
		~Example () { delete p; }
		// custom deep copy of the string's contents
		Example (const Example& x) : p(new string(x.content())) {} 	// alloc storage for new string
		// access the content of the string
		const string& content() const { return *p; }
};

// copy assignment - can copy obj on any assignment (not just during init or construction)
MyClass c0;
MyClass c1 (c0); 		// call copy constructor
MyClass c2 = c1; 		// call copy constructor; NOT assignment (just another syntax for 1-arg constructor)
c0 = c1; 				// copy assignment called since obj already init
	// copy assignment operator = is an overload of equals sign:
	// takes value of class as param, roughly returns *this
MyClass& operator= (const MyClass&); 	// defined implicitly this way if no copy or move constructor def
	// AGAIN, this is SHALLOW copy

// writing a deep copy version of the copy assignment operator
Example& operator= (const Example& x) {
	delete p; 						// delete currently pointed string
	p = new string (x.content()); 	// alloc space for string and copy it
	return *this;
}
// better yet, reutilize string since string not constant
Example& operator= (const Example& x) {
	*p = x.content();
	return *this;
}

// move constructor and assignment - transfer content from src obj to dest obj
	// only happens when the src of the value is an unnamed object
	// examples of "unnamed temporaries": return vals of functions, type-casts
	// since not used for anything else, copy not required
// move constructor on unnamed temporary
MyClass fn(); 			// func returning MyClass obj
MyClass c0;	 			// default constructor
MyClass c1 = c0; 		// copy constructor
MyClass c2 = fn(); 		// move constructor
c0 = c1;				// copy assignment
c2 = MyClass(); 		// move assignment

// move constructor and assignment members take param "rvalue reference to the class itself"
MyClass (MyClass&&); 				// move constructor
MyClass& operator= (MyClass&&);		// move assignment
	// rvalue reference is specified c 2 ampersands
	// val&& matches temporaries or references of this type

// copying vs moving very useful for objects that allocate and delete storage
	// COPY: alloc mem to B and copy entire content of A to newly alloc B mem
	// MOVE: transfer mem already allocated to A over to B without alloc new storage
			// MOVE is thus simply copy of pointer
class Example {
		string* p;
	public:
		Example (const string& s) : p (new string(s)) {}
		~Example () { delete p; }
		// move constructor
		Example (Example&& x) : p (x.p) { x.p=nullptr; }
		// move assignment
		Example& operator= (Example&& x) {
			delete p;
			p = x.p;
			x.p = nullptr;
			return *this;
		}
		// access string content
		const string& content() const { return *p; }
		// addition
		Example operator+ (const Example& rhs) {
			return Example(content()+rhs.content());
		}
};
	// /!\ rvalue params possible for any func param, most often just used for move constr
	// source of errors difficult to track if used without care /!\

// Implicit members declared in specific circumstances
/*
 * 	Default constructor 	if no other constructors
 *  Default destructor 		if no other destructors
 * 	Copy constructor 		if no move constructor or move assignment
 * 	Copy assignment 		if no move constructor or move assignment
 * 	Move constructor  		if no destructor, copy constructor nor copy/move assignment
 * 	Move assignment 		if no destructor, copy constructor nor copy/move assignment
 */
 // class CAN select which implicit members are included or deleted using "default" and "delete"
class Rect {
 	 	int w,h;
 	public:
 		// Rect can be constructed with two arguments
 		Rect (int x, int y) : w(x), h(y) {}
 		// Rect can be implicitly "default-constructed" with no arguments
 		Rect () = default;
 		// Rect cannot be implicitly "copy-constructed" by passing Rect& obj to Rect class
 		Rect (const Rect& other) = delete;
 		int area() { return w*h; }
};

// now IMPLICIT copy construction is no longer valid
Rect r0;
Rect r1 (3,2);
Rect r1 (r0); 	// INVALID because copy constructor set to delete

// HOWEVER you could still explicitly define a copy constructor
Rect::Rect (const Rect& other) : w(other.w), h(other.h) {}

// Terminology: "=default" NOT equal to the default constructor (invoked with no args)
	// BUT equal to constructor that's implicitly def when not deleted

// Best practice: classes that define one copy/move constr or one copy/move assign (NOT both)
	// should specify "default" OR "delete" on other special member funcs they don't assign

/*
 * 	Friendship and inheritance
 */
// non-member friend can access private and protected members of a class
	// func must be declared friend within class
class Rect {
	...
	friend Rect duplicate (const Rect&);
};
Rect duplicate (const Rect& param)
{
	Rect r;
	r.w = param.w*2;
	r.h = param.h*2;
	return r;	
}
int main () {
	Rect rectangle;
	Rect square (2,2);
	rectangle = duplicate (square); 	// accesses private w and h
}
// friend functions typically used to access private/protected members between 2+ classes

// friend classes - similarly have access to private/protected members of another class
class Square; 		// need empty declaration of class because referenced in Rect!
class Rect {
	... 
	void convert (Square);
};
class Square {
	friend class Rect;
	private:
		int side;
	public:
		Square (int a) : side(a) {}
};
void Rect::convert (Square sq) {
	w = sq.side; 	// friend Rect can access private Square::side
	h = sq.side;
}
	// friends are NOT reciprocal: friended is not auto friend back
	// friends are NOT transitive: friend of friend is not auto friend

// inheritance between classes
class Polygon {
	protected: 					// accessible from derived classes instead of private
		int w,h;
	public:
		void set_vals (int a, int b)
		{ w=a; h=b; }
};
class Rect: public Polygon { 	// inherit from base class
	public:
		int area () { return w*h; }	
};

// 	access 						public	protected 	private
// 	members of same class 		T 		T 			T
//	members of derived class 	T 		T 			F
// 	non-members(*) 				T 		F 			F
// 	(*) incl main(), another class, another function

// take another look at inheritance from base class access level
class DerivedClass : public BaseClass {}; 		// "public" declares MAX access level
	// if PROTECTED, all PUBLIC members would be PROTECTED and PRIVATE would remain PRIVATE
	// if PRIVATE, all PUBLIC and PROTECTED and PRIVATE members would be PRIVATE
// /!\ this doesn't restrict derived class from setting own access levels on its members
// /!\ best practice usu set public and set access levels on base class members not during inheritance

// what is NOT inherited
	// - private members of base class
	// - friends of base class
	// - assignment operator= members of base class
	// - constructors and destructor of base class (*)
// (*) however these are called DIRECTLY by derived class

// derived class automatically calls default constructor of base class (and not its own default)
// call a different constructor of the base class instead of the default
derived_constructor_name (params) : base_constructor_name (params) { ... }

class Mother {
	public:
		Mother () { cout << "Mother: no params\n"; }
		Mother (int a) { cout << "Mother: int param\n"; }
};
class Daughter {
	public:
		Daughter (int a) 					// calls default constructor on Mother
		{ cout << "Daughter: int param\n"; }
};
class Son {
	public:
		Son (int a) : Mother (a) 			// calls 1 int param constructor on Mother
		{ cout << "Son: int param\n"; }
};
// you'll get the first message from Mother followed by the one from Daughter in main ()
Daughter je(0);
// you'll get the second message from Mother followed by the one from Son in main ()
Son jo(0);

// multiple inheritance - all members from mult classes (c "what is NOT inherited" restrictions above)
class Rect : public Polygon, public Output;


/*
 * 	Polymorphism
 */
// pointer to derived class is type-compatible c pointer to base
class Polygon {
	...
};
class Rect: public Polygon {
	...
	int area () {
		...
	}
};
class Triangle: public Polygon {
	...
	int area () {
		...
	}
};
int main () {
	Rect r;
	Triangle t;
	// pointer to derived classes of type parent class
	Polygon * poly1 = &r;
	Polygon * poly2 = &t;
	poly1->set_values(2,2); 		// can call method from derived class
}

// equivalent results from these statements (incl deref)
(*poly1).set_values(2,2);
poly1->set_values(2,2);
r.set_values(2,2);
	// pointer to that type can only access members on that type
	// so poly1 can't access e.g. an area() function defined on Rect

// virtual allows redefining method in a derived class
	// which is one way to skirt poly1's area() problem mentioned above
class Polygon {
	...
	virtual int area () 
	{ return 0; }
};
// had this been base class instead could've called area on Rect poly1
poly1->area(); 		// this is now a "Polymorphic class"
// base Polygon (declares virtual) and the derived Rect (inherits virtual) are "Polymorphic classes"

// abstract class
class Polygon {
	protected:
	 	int w, h;
	public:
		void set_values (int a, int b) {
			w = a; h = b;
		}
		virtual int area () =0; 	// PURE virtual function that has NO definition
};
 	// such class is an "abstract base class" and cannot instantiate obj
// still create pointers to it and 
Polygon * ppoly1;
// still use polymorphism and dereferencing
int main () {
	Rectangle rect;
	Triangle trngl;
	Polygon * polyptr1 = &rect;
	Polygon *polyptr2 = &trngl;
	polyptr1->set_values(2,2);
	cout << polyptr1->area();
}

// abstract base class implementation using "this" c virtual so pointer can call proper function on derived classes
	// even though no function implemented on base!
class Polygon {
	protected:
		int w, h;
	public:
		void set_values (int a, int b) { w=a; h=b; }
		virtual int area () =0;
		void print_area() {
			cout << this->area() << '\n'; 	// note the keyword "this"
		}	
};
class Triangle : public Polygon {
 	... 	// area function	
};
class Rectangle : public Polygon {
	...	 	// area function
};
int main () {
	Rect r;
	Triangle t;
	Polygon * p1 = &r;
	Polygon * p2 = &t;
	p1->set_values(2,2);
	p2->set_values(3,10);
	p1->print_area(); 	 	// will print result of Rect's area()
	p2->print_area(); 	 	// will print result of a Triangles's area()
}

// can of course combine with constructor initializers and dynamic memory
class Polygon {
	protected:
		int w, h;
	public:
		Polygon (int a, int b) : w(a), h(b) {}
		void set_values (int a, int b) { w=a; h=b; }
		virtual int area () =0; 			// pure virtual func; an abstract base class
		void print_area() {
			cout << this->area() << '\n'; 	// note keyword "this" for derived class
		}	
};
class Triangle : public Polygon {
	public:
		Triangle (int a, int b) : Polygon (a,b) {}
 		int area () { return (0.5 * w * h); }
};
class Rect: public Polygon {
	public:
		Rect (int a, int b) : Polygon (a,b) {}
		int area () { return (w * h); }
};
int main () {
	Polygon * p1 = new Rect (2,2); 		// dyn "new" Rect but pointer to Polygon ptr type
	Polygon * p2 = new Triangle (7,4); 	// dyn "new" Triangle but pointer to Polygon ptr type
	p1->print_area(); 	 				// print result of Rect's area()
	p2->print_area(); 	 				// print result of a Triangles's area()
	delete p1;
	delete p2;
	return 0;
}


/*
 * 	Type conversions
 */

// implicit when value copied to compatible type
short a = 1000;
int b = a; 		// "standard conversion" btwn fundamental numerical types and bool, some ptrs
	// "promotion" to int from smaller type, or double from float
	// other conversions not necessarily represent the same value accurately
		// - neg to unsigned becomes 2's complement: -1 largest, -2 second largest
		// - bool have false equal to zero or nullptr, everything else to 1
		// - float-like to integer-like drops decimals; "undefined behavior" if not representable
		// - "implementation specific" btwn same num types (floating to floating, integer to integer), valid
	// pointer conversions
		// - null ptr to ptr of any type
		// - ptr of any type to void pointer
		// - "pointer upcast": derived class to "accessible" and "unambiguous" base class (w/o mod its const/volatile)

// implicit with classes - 3 types
class A {};
class B {
	public:
		// single-argument constructor conversion
		B (const A& x) {}
		
		// assignment conversion
		B& operator= (const A& x) { return *this; }
		
		// type-cast operator conversion
		operator A() { return A(); } 	// special syntax: destination type and empty parens
										// return type is dest type so not specified
};
int main () {
	A a;
	B b = a; 		// call constructor
	b = a; 			// call assignment
	a = b;			// call type-cast operator
	return 0;
}

// "explicit" keyword
	// added to class B above
	void func (B arg) {}
		// could be called by arg of type A!
		// e.g. func (a);
// prevent by marking with "explicit"
class B {
	public:
		explicit B (const A& x) {} 		// constructor marked explicit
		B& operator= (const A& x) {
			return *this;
		}
		operator A() { return A(); }
};
void func (B x) {}
// now can't call that constr from obj of type A
int main () {
	A a;
	B b (a);
	b = a;
	a = b;
	func (a); 	// CANNOT call since B's constructor marked explicit
	func (b); 	// can call
}
// "explicit" class behavior
	// - can no longer use equals syntax to construct B
	// 		e.g.	B b = a; 	no longer works
	// - constructors without explicit are "converting constructors"
	// - type-cast member functions can also be explicit (operator + type syntax)
		// e.g. 	explicit operator bool() { return true; }
		// OK if class::operator bool(), ERROR if copy initialization considers class::operator bool()

// explicit type casting
	// func calls - C++ allows one implicit conversion per arg
double x = 10.5;
int y;
y = int (x); 	// functional notation
y = (int) x; 	// c-like cast notation
// watch out for indiscriminate class and pointer-to-class casting - compiles but runtime errors
class X {
	double i,j;
};
class Sum {
		int x,y;
	public:
		Sum (int a, int b) { x=a; y=b; }
		int result() { return x+y; }
};
int main () {
	X x;
	Sum * psum; 				// declares pointer
	psum = (Sum*) &x; 			// but assigns to cast of pointer of unrelated type!
	cout << psum->result(); 	// since can convert any ptr to any other ptr type, runtime error or unexpected
	return 0;
}

// "specific casting operators" instead to restrict type casting
dynamic_cast <new_type> (expression_to_cast); 		// dynamic casts
static_cast <new_type> (expression_to_cast); 		// static casts
reinterpret_cast <new_type> (expression_to_cast); 	// reinterpret casts
const_cast <new_type> (expression_to_cast); 		// const casts

// dynamic cast - convert if result is valid ptr to obj of destination type
	// - only c ptrs and references to classes or void*
	// - can upcast (from ptr to derived clas to ptr base class)
	// - can also downcast polymorphic classes (inherits virtual)
	// - can cast null ptrs btwn pointer types (incl unrelated classes)!
	// - can cast any ptr type to a void*
class Base { virtual void dummy() {} };
class Derived: public Base { int a; };
int main () {
	try {
		Base * p0 = new Derived; 			// p0 points to obj of type Derived
		Base * p1 = new Base; 				// p1 points to obj of type Base
		Derived * p2; 						// holder to try and assign type-cast obj
		p2 = dynamic_cast<Derived*>(p0); 	// p0 points to full object of type Derived
		if (p2==0) cout << "Null ptr on first cast.\n"; 	// won't pass
		p2 = dynamic_cast<Derived*>(p1);	// p1 points to incomplete object of class Derived (it's Base)
		if (p2==0) cout << "Null ptr on second cast.\n"; 	// will pass and output mssg
	} catch (exception e) { cout << "Exception: " << e.what(); }
	return 0;
}

// static cast - convert btwn ptrs to related classes (upcasts and downcasts)
	// - does not check that objects are full objects of the type unlike dynamic
	// - however does not have runtime type-safety check overhead that dynamic has
	// - can convert from void* to any ptr type
	// 		- guarantees that if value obtained by converting from same ptr type, resulting value is same
	// - can convert integers, floating-point and enums to enums
	// - can explicitly call single-arg constructors
	// - can explicitly call conversion operators
	// - can convert to rvalue reference (reference to the MyClass&& itself - see move constr & assgn above)
	// - can convert enum to integers or floating point
	// - can convert any type to void (discards value)
class Base {};
class Derived: public Base {};
Base * a = new Base;
Derived * b = static_cast<Derived*>(a); 	// valid code BUT incomplete obj so runtime errors if deref


// reinterpret cast - any pointer type to any other pointer type
	// - simple binary copy of val from one ptr to other
	// - neither content nor ptr is checked
	// - can cast ptr to/from integer (only guaranteed to work back if integer type large enough to contain it)
	// - works diff from static cast, resulting in non-portable reinterp of binary representations of types
		// - these reinterpretations as "low-level operations"
class A { ... };
class B { ... };
A * a = new A;
B * b = reinterpret_cast<B*>(a); 	// works but points to diff, maybe uncompatible, class - deref B is unsafe

// const cast - sets or removes the constness of the pointed object
void print (char * str) { 		// works bc fn does not attempt to write to pointed object
	cout << str << '\n'; 			// /!\ if it did try it would result in "undefined behavior" /!\
}
int main () {
	const char* c = "some text";
	print ( const_cast<char*> (c) ); 	// pass const ptr to a fn that expects a non-const arg
	return 0;
}

// typeid - type checking
	// - returns ref to const obj of the type type_info (defined in standard header <typeinfo>)
	// - can be compared to any other typeid using == or !=
	// - can use name() to obtain char sequence representing the type/class name (null-terminated \0)
		// - output of name() definitely depends on your compiler, and isn't necessarily simple name
typeid (expression)
if (typeid(a)==typeid(b)) { ... }

// typeid applied to classes
	// - uses RTTI to track type of dynamic objs
	// - if polymorphic class, result is type of most derived complete obj
	// - considers pointer type itself when looking at pointers
	// - BUT considers dynamic type when looking at objects themselves
	// - bad_typeid exception if checking a dereferenced ptr with a null value (*nullptr)
class Base { virtual void fn() {} };
class Derived: public Base {};
int main () {
	try {
		Base* a = new Base;
		Base* b = new Derived;
		cout << "b is: " << typeid(b).name() << '\n'; 			// prints that b is "class Base"
		cout << "b* is: " << typeid(*b).name() << '\n'; 		// prints that b is "class Derived"
		cout << typeid(a).name() << typeid(a*).name() << '\n'; 	// prints "class Baseclass Base"
	} catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
	return 0;
}


/*
 * 	Exceptions
 */

// as way to react to exceptional situations
	// - excpetion "handlers" are special functions
	// - "try-block" puts code under exception inspection
	// - exception thrown using "throw" inside try block
	// - handlers declared c "catch" immediately after try block

#include <iostream>
using namespace std;

int main () {
	try {
		throw 20; 		// accepts 1 param to pass as arg to catch
	}
	catch (int e) { 	// checks against type passed by throw - only caught if types match!
		cout << "Exception Nr. " << e << '\n'; 		// will print 20
	}
	return 0;
}

// catch any type of exception
try {
	// try block
}
catch (int param) {}
catch (char param) {}
catch (...) { cout << "default exception"; } 	// in this case catch any non-int non-char exception
	// after catch runs, resumes AFTER try-catch, NOT after throw keyword

// nested try-catch to forward exception up to external level - throw c no param
try {
	try {

	} catch (int e) {
		throw;
	}
}
catch (...) {
	cout << "Exception occured.";
}

// "dynamic exception specifications" - older code, deprecated but still supported
double myfunc (char param) throw (int);
	// - declares function taking one char and returning a double
	// - if throws exception of type other than int, calls std::unexpected instead of handler or std::terminate
int myfunc (int param) throw(); 	// call std::unexpected for ANY exception type
int myfunc (int param); 			// normal exception handling - look for handler

// standard exceptions with <exception> header
	// - includes virtual member function what()
	// - what() returns null-terminated char sequence (of type char*)
	// - what can be overwritten in derived classes to contain desc of exception
#include <iostream>	
#include <exception>
using namespace std;
class myexception: public exception
{
	virtual const char* what() const throw() 	// overwritten what() func
	{
		return "Reached my exception!"; 		// overwritten to contain desc of exception
	}
} myexception;

int main () {
	try {
		throw myexcpetion;
	} catch (exception& e) { 		// catch exception class by reference, here including our derived myexception
		cout << e.what() << '\n'; 	// will reach ours
	}
	return 0;
}

// C++ standard library components throw exceptions, all derived from this exception class
bad_alloc 			// thrown by new on alloc fail
bad_cast 			// thrown by dynamic_cast on dynamic cast fail
bad_exception 	 	// thrown by dynamic exception specifiers
bad_typeid 			// thrown by typeid
bad_function_call 	// thrown by empty function objects
bad_weak_ptr 		// thrown by shared_ptr when passed a bad weak_ptr

// header <exception> defines two generic types that can be inherited by custom exceptions
logic_error
runtime_error

// standard exceptions typically need to be checked on mem alloc!
int main () {
	try {
		int* myarray = new int[1000];
	}
	catch (exception& e) { 					// catchable bad_alloc from base exception (captured by ref exception&)
		cout << "Standard exception: " << e.what() << endl; 	// will catch bad_alloc bc derived from exception
	}
	return 0;
}

/*
 *	Preprocessor directives - lines beginning c #
 */
// directive replaces any occurrence of (identifier) with (replacement), which is an expression, block, anything
#define TABLE_SIZE 250
int tbl[TABLE_SIZE]; 	// -> effectively equiv: 	int tbl[250]

// parameters to define func macros
#define getmax(a,b) a>b?a:b
	// replaces every getmax c 2 args -> the expression evaluates as if it was function

// not affected by block structure because evaluates until it's undefined
#define TABLE_SIZE 250
int table0[TABLE_SIZE]; 	// effectively: 	int table0[250]
#undef TABLE_SIZE
#define TABLE_SIZE 200
int table1[TABLE_SIZE]; 	// effectively: 	int table1[200]

# special operators in function macros - replace arg c string literal of arg
#define str(x) #x
cout << str(sometxt); 		// effectively: 	cout << "sometxt"

# special op in func macros - concatenate 2 args c no blank spaces
#define combo(a,b) a ## b
combo(c,out) << "sometxt"; 	// effectively: 	cout << "sometxt"
	// - tricky bc macro defs replace BEFORE ANY syntax checks
	// - tricky bc code becomes less readable if heavy use
	// - tricky bc syntax in many cases very different from normal C++ expressions

// Conditional Includes
	// - use or discard line based on condition met
	// - "ifdef" only if the specified macro is defined
	// - "ifndef" only if the specified macro is NOT defined
	// - "if", "elif, "else" evaluate constant expressions
	// - "endif" to end series of chained expressions
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif

#ifndef TABLE_SIZE
#define TABLE_SIZE 250
#endif

#if TABLE_SIZE>250
#undef TABLE_SIZE
#define TABLE_SIZE 250

#elif TABLE_SIZE<50
#undef TABLE_SIZE
#define TABLE_SIZE 50

#else
#undef TABLE_SIZE
#define TABLE_SIZE 250
#endif

int tbl[TABLE_SIZE];

// use "if" with "defined" and "!defined" to achieve same ifdef/ifndef behavior
#if defined ARRAY_SIZE
#define TABLE_SIZE ARRAY_SIZE
#elif !defined BUFFER_SIZE
#define TABLE_SIZE 256
#else
#define TABLE_SIZE BUFFER_SIZE
#endif

// Line control - error reporting, assign custom filename and line number
// 	syntax: #line number "filename"
#line 20 "assigning variable"
int a?; 	// code now generates error and gives this location of error: assigning variable", line 20

// #error directive - abort compilation at this line and generate compilation error
#ifndef __cplusplus
#error A C++ compiler is required!
#endif
	// will abort if macro name __cplusplus is not defined

// #include a source file
#include <header>
#include "file"
	// - header provided by implementation, e.g. library iostream
	// - header may exist as files or other implementation, that's all "implementation defined"
	// - file searched for in an "implementation defined" way
	// - file search generally includes current path
	// - file not found interpreted (generally) as if quotes were <>, meaning it's a HEADER directive!

// #pragma - specify diverse options to compiler
	// - specific to your compiler+platform
	// - if compiler doesn't support an arg, pragma simply ignored
	// - never generates syntax error

// predefined macro names
__LINE__		// integer rep current line in compiled source code file
__FILE__ 		// string literal c presumed name of compiled source code file
__DATE__		// string literal "Mm dd yyyy" c date on which compilation process began
__TIME__ 		// string literal "hh:mm:ss" c time at which compilation process began
__cplusplus 	// integer constant defined by all C++ compilers, depends on version of standard supported
					// 199711L 	is for ISO C++ 1998/2003
					// 201103L 	is for ISO C++ 2011
__STDC_HOSTED__ // 1 if hosted implementation (all standard headers) 0 otherwise

// optionally defined macros
__STDC__ 		// for C: defined to 1, conforms to C standard
				// for C++: implementation defined
__STDC_VERSION__ 			// in C: 199401L, 199901L, 201112L; C++: implementation defined
__STDC_MB_MIGHT_NEQ_WC__	// 1 if multibyte encoding might give char in char literals diff val
__STDC_ISO_10646__			// yyyymmL specifying date of Unicode standard followed by encoding of wchar_t chars
__STDCPP_STRICT_POINTER_SAFETY__	// 1 if implementation has strict pointer safety
									// (among relaxed/preferred/strict - see get_pointer_safety)
__STDCPP_THREADS__ 			// 1 if program can have multiple threads
	// maybe more threads in particular implementations
#include <iostream>
int main () {
	std::cout << "Current line number " << __LINE__;
	std::cout << " of file " << __FILE__ << " compiled beginning on " << __DATE__;
	std::cout << " at time " << __TIME__ << ". Compiler __cplusplus value of " << __cplusplus << '\n';
	return 0;
}


/*
 * 	File Input/Output
 */

// stream classes (derived directly from istream, from which we've been using cin, and ostream, cout)
#include <ofstream> 	// write
#include <ifstream> 	// read
#include <fstream> 		// both read and write
	// the diff from cin and cout is the use of physical files

#include <iostream>
#include <fstream>
using namespace std;

int main () {
	ofstream myfile;
	myfile.open ("example.txt"); 		// create file
	myfile << "Writing to file.\n"; 	// write filestream
	myfile.close(); 					// close file
	return 0;
}

// open a file - assoc to real file
fileobj.open (filename, mode); 	// string is filename
	// mode is optional param
	// ios::in  	open for input ops
	// ios::out 	open for output ops
	// ios::binary 	open in binary mode
	// ios::ate 	set the initial position at the end of file (instead of beginning)
	// ios::app 	all output ops are performed at end of file (appended)
	// ios::trunc 	if file is opened and already exists, delete prev content and replace by new

// can combine modes c bitwise OR |
ofstream myf;
myf.open ("example.bin", ios::out | ios::app | ios::binary);

// open member functions have default mode
	// ofstream 	ios::out 					assumed even if only ios::in passed in
	// ifstream 	ios::in 					assumed even if only ios::out passed in
	// fstream 		ios::in | ios::out 			default value OVERRIDDEN if another mode passed in

// binary mode io ops are independent of formatting; non-binary text may format special chars
	// - like newline or carriage return

// stream classes have constructor that automatically opens the file - also valid way to open file!
ofstream fileobj ("example.bin", ios::out | ios::app | ios::binary);

// member func is_open to check success
if (fileobj.is_open()) { /* do something w input and output */ }

// close a file - notify operating system and free up resources
	// - flushes associated buffers and closes the file
	// - can now use stream obj to open another file
	// - file is free to open by other processes
	// - if obj destroyed while associated c open file, destructor auto calls .close
fileobj.close();

// Text files - writing to files without ios::binary so they're non-binary
#include <iostream>
#include <fstream>
using namespace std;
int main () {
	ofstream myf ("example.txt");
	if (myf.is_open()) {
		myf << "Writing a line.\n";
		myf.close();
	}
	else cout << "Could not open file";
	return 0;
}

// Text files - reading from files without ios::binary
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main () {
	string line;
	ifstream f ("example.txt");
	if (f.is_open()) {
		while ( getline (f,line) ) { 	// true while stream itself ready for more ops
										// false if end of file or some error
			cout << line << '\n';
		}
		f.close()
	}
	else cout << "Could not open file";
	return 0;
}

// checking state flags - all return boolean
f.bad() 	// true if read or write fails, e.g. write to unopened file or to device with no space
f.fail() 	// true if bad() PLUS if format error, e.g. alpha char extracted while trying to read integer
f.eof() 	// true if file open for reading has reached end
f.good() 	// false if any of the above would return true (very generic; NOT just the opp of bad)
// reset the state flags
f.clear()

// stream object keeps at least one internal position
	// get pos: ifstream (like istream) keeps the loc of element to be read in next input op
	// put pos: ofstream (like ostream) keeps the loc of where next element must be written
	// fstream keeps both get and put
f.tellg() 	// return the value of get position (of member type streampos)
f.tellp() 	// return the value of put position (of member type streampos)

// change the values - counting from the beginning of the file
f.seekg(position);
f.seekp(position);

// other option with 2 params - offset is one of ios::beg, ios::cur, ios::end
f.seekg(offset, direction);
f.seekg(offset, direction);

...
int main () {
	streampos begin, end; 						// notice the type STREAMPOS not INT
	ifstream f ("example.bin", ios::binary); 	// open the file using constructor
	begin = f.tellg();							// the first position for reading lines in
	f.seekg (0, ios::end); 						// move to end
	end = f.tellg(); 							// final read position
	f.close();
	// streampos can be added/subtracted against each other
	cout << "file size: " << (end-begin) << " bytes\n";
	return 0;
}

// streampos for position is just an alias of ios::pos_type
// streamoff for offset is just an alias of ios::off_type
	// the non-member types (ios::...) are more generic and apply even when streams use odd characters

// binary files
	// - extraction << and insertion >> ops are not efficient
	// - functions like getline are not efficient
	// - bc data not being formatted
	// - and bc data isn't in neat lines
// write and read funcs (inherited members of ostream into ofstream and istream to ifstream, and fstream has both)
write (memory_block, size);
read (memory_block, size);
	// memory_block is char* for the address of array of bytes where read data stored
	// size is integer specifying num chars to read or write from/to the block
...
int main () {
	streampos size;
	char * memblock;
	ifstream f ("example.bin", ios::in|ios::binary|ios::ate) {
		size = f.tellg(); 				// bc you're at end of file
		memblock = new char [size]; 	// buffer large enough to hold file
		f.seekg (0, ios::beg); 			// set to beginning of file
		f.read (memblock, size);
		f.close();
		cout << "Entire file content is now in memory";
		delete[] memblock;
	}
	else cout << "Unable to open file";
	return 0;
}

// buffers and synchronization - streambuf
	// - put to buffer instead of physical medium
	// - when file closed: buffers not flushed are synchronized, data written/read to physical medium
	// - when buffer full: automatically synchronized
	// - explicit manipulators: flush and endl explicitly manipulate (synchronize) the stream buffer
	// - explicit member func: sync() immed sync and return int equal to 0 (or -1 if no buffer or if failure)