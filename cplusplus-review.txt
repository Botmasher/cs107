// http://www.cplusplus.com/doc/tutorial/


// sample program to add two numbers
00000	10011110
00001	11110100
00010	10011110
00011	11010100
00100	10111111
00101	00000000

// same program in C++ to compile
int a, b, sum;
     
cin >> a;
cin >> b;
             
sum = a + b;
cout << sum << endl;


/*
 * 	Example program anatomy
 */

#include <iostream> 			// preprocessor directive (here: include standard i/o ops)
								// blank line
int main() 						// function declaration; "main" is special in C++
{
  std::cout << "Hello World!"; 	// print to screen using character out; << is the insertion op
}

// same output but introducing namespace visibility to allow for unqualified cout
#include <iostream>
using namespace std;
int main() { cout << "Hello World!"; }


/*
 * 	Variables
 */

// Fundamental types (see below for compound types like strings)
char s 					// at least 8 bits
char 16_t s 			// at least 16 bits
char 32_t s 			// at least 32 bits
wchar_t s 				// largest supported char set
signed char x 			// at least 8 bits
signed short int x 	 	// at least 16 bits
signed int x 			// at least 16 bits
signed long int x 		// at least 32 bits
signed long long int x 	// at least 64 bits
unsigned... 			// for ints, same as signed counterparts
float
double
long double
bool
void
decltype(nullptr) 		// null pointer

// c-like vs constructor vs uniform initialization
int x = 0;
int x (0);
int x {0};

// Type deduction
auto y = x; 		// y deduced to be int
decltype(x) y; 		// y deduced to be int

// Compound types like strings
#include <iostream>
#include <string> 				// include preprocessor directive
int main () {
	string s = "my text"; 		// initialize
	std::cout << s  << endl; 	// endl manipulator prints newline and flushes stream
}

// Constants
75
0113 	// 75 in octal
0x4b 	// 75 in hex
75u 	// unsigned suffix
75l 	// long suffix
75ul 	// unsigned long suffix
75lu 	// unsigned long suffix
6.02f 	// float
3.14L 	// long
'c' 	// character literal
"char" 	// string literal
const double pi = 3.14 	// convenient way to set and use a const instead of literal

#define PI 3.14 		// preprocessor definitions for const instead
#define NEWLINE '\n' 	// identifier -> replacement (#define IDENTIFIER REPLACEMENT)

// operators
y = 2 + (x=3); 	// assignment operations can be evaluated
++x;
x+=1;

// relational and comparison operators 	== != > < >= <=

// logical operators 	! || &&

// ternary ?

// comma for multiple assignment ,

// bitwise & | ^ ~ << >>

// explicit type casting
int i = (int) 3.14;

// get size of one type or one variable in bytes
x = sizeof (char);

// standard io
#include <iostream>
using namespace std;
int main () {
	int age;
	cin >> age;
	cout << age << endl;
}

// io treat string as stream
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
int main () {
	// separate process of getting input from interpreting data
	string s;
	int age;
	int year;
	cout << "Your age: ";
	getline (cin,s);
	stringstream (s) >> age;
	cout << "Year: ";
	getline (cin,s);
	stringstream (s) >> year;
	cout << "It is " << year << " and you are " << age << endl;
	return 0;
}

/*
 * 	Statements and flow control
 */
// indentation and line breaks no effect
if (x) { cout << "Value: "; cout << x; }

// branches
if (x)
	cout << x;
else
	cout << "not x";

// while and do while loops
while (x < 100) {}
do {} while (x != 100)

// for loops; all semicolons required even blank
// terminology:
// 		for (INITIALIZATION; CONDITION; INCREASE) {}
for (int n=0; n>0; --n) {}
for (;n>0;) {}
for (n=0, i=10; n!=i; ++n, --i) {}

// range-based for loop
// 		for ( declaration : range ) statement;
for (char c : string ) {}

// break and continue "jump" statements

// goto "jump" statement: identify a label and then goto
// 	/!\ unconditional jump, ignores nesting, no auto stack unwinding
int main () {
	int n = 3;
newlabel:
	--n;
	if (n>0) goto newlabel;
}

// switch case
switch (x) {
	case 1:
	case 2:
	case 3:
		break;
	default:
		cout << "x!"
}


/*
 * 	Functions
 */
// main() is the only function called automatically
// all other funcs exec from main
int add (int a, int b) {
	int res;
	res = a + b;
	return res;
}
int main() {
	int z = 4 + add (5, 3);
	cout << z << endl;
}

// return 0 is implicit in main(), though some programmers prefer explicit
int main () {
	return 0;
}

// calling functions w params taken by values causes copies of values to be made
// passing by reference no longer does copy but var itself!
void duplicate (int& a) {
	a*=2;
}

int main() {
	int x = 1;
	duplicate (x);
	cout << x << endl;
	return 0;
}


// to make sure that ref vars not modified, make the params constant
int add (const int& a, const int& b) {
	return a+b;
}
// extremely popular for compound types (e.g. string)
// extremely efficient for params of compound types


// use INLINE to tell compiler to insert the statements inline
// instead of using function overhead like stacked arguments, jumps, ...
inline string concatenate (const string& x, const string& y) {
	return x+y;
}
// done automatically in some compilers when they see efficiency gain anyhow

// default val
int integerstuff (int x=0) {}

// declaring prototype of a function (define it somewhere else in code)
int prototype (int, int); 	// notice that param names not needed but types are
// useful in cases where functions required before defined, e.g. mutual checks

// recursivity
long factorial (long a) {
	if (a > 1)
		return (a * factorial (a-1));
	else
		return 1;
}

// overloaded functions
int add (int a, int b) {
	return (a+b);
}
double add (double a, double b) {
	return (a+b);
}

// template types using CLASS or TYPENAME (synonymous)
template <class SomeType>
SomeType add (SomeType a, SomeType b) {
	return a+b;
}

// template arguments
template <typename T>
T add (T a, T b) {
	T sum = a+b; 	// notice local var of type T
	return sum;
}
// then when called in main()
add<int> (x,y);


// compile time not run time for template params!
template <class T, int N>
T fixed_mult (T val) {
	return val * N;
}
// therefore second template arg must be constant here
int main() {
	fixed_mult<int,2> (3); 	// creates func that ALWAYS multiplies by 2
							// and then passes it in a 3
}

// visibility, local scope until end of block, namespaces
// namespace identifier { named_entities }
namespace myInts {
	int a,b;
}
myInts::a;

// declaring multiple segments in the same namespace
namespace a { int a; }
namespace b { int b; }
namespace a { int b; }

// using keyword for namespaces
using namespace a;

// or in main()
int main() {
	using namespace a;
}

// global and namespace vars allocated for duration of program
// STATIC vars vs AUTOMATIC storage for local vars
	// AUTOMATIC only avail in block in which declared; after that mem can be used for other
	// non-explicit STATIC initialize to 0
	// non-explicit AUTOMATIC do not initialize
